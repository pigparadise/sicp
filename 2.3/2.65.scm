(define (make-tree root left right)
  (list root left right)
)

(define (root tree) (car tree))

(define (left-branch tree) (cadr tree))

(define (right-branch tree) (caddr tree))

(define (tree->list tree) ;; O(N)
  (cond ((null? tree) '())
        ((number? tree) (list tree))
        (else (append (tree->list-1 (left-branch tree))
                      (cons (root tree)
                            (tree->list-1 (right-branch tree))
                      )
              )
        )
  )
)

(define (list->tree items)
  (car (p-tree items (length items)))
)

(define (p-tree items n) ;; O(N)
  (if (= n 0)
      (cons '() items)
      (let ((left-size (quotient (- n 1) 2)))
        (let ((left-result (p-tree items left-size)))
          (let ((left-tree (car left-result))
                (non-left-items (cdr left-result))
                (right-size (- n (+ left-size 1)))
               )
            (let ((this-root (car non-left-items))
                  (right-result (p-tree (cdr non-left-items) right-size))
                 )
              (let ((right-tree (car right-result))
                    (remaining-items (cdr right-result))
                   )
                (cons (make-tree this-root left-tree right-tree)
                      remaining-items
                )
              )
            )
          )
        )
      )
  )
)

(define (inter-order-set set1 set2) ;; O(N)
  (if (or (null? set1) (null? set2))
      '()
      (let ((x1 (car set1))
            (x2 (car set2))
           )
        (cond ((= x1 x2)
               (cons x1 (inter-order-set (cdr set1) (cdr set2)))
              )
              
              ((< x1 x2)
               (inter-order-set (cdr set1) set2)
              )

              ((> x1 x2)
               (inter-order-set set1 (cdr set2))
              )
        )
      )
  )
)


(define (union-order-set set1 set2) ;; O(N)
  (if (or (null? set1) (null? set2))
      '()
      (let ((x1 (car set1))
            (x2 (car set2))
           )
        (cond ((= x1 x2)
               (cons x1 (union-order-set (cdr set1) (cdr set2)))
              )
              
              ((< x1 x2)
               (cons x1 (union-order-set (cdr set1) set2))
              )

              ((> x1 x2)
               (cons x1 (union-order-set set1 (cdr set2)))
              )
        )
      )
  )
)


(define (inter-tree-set set1 set2) ;; 4*O(N) -> O(N)
  (list->tree (inter-order-set (tree->list set1)
                               (tree->list set2)
              )
  )
)

(define (union-tree-set set1 set2) ;; 4*O(N) -> O(N)
  (list->tree (union-order-set (tree->list set1)
                               (tree->list set2)
              )
  )
)


(define a (make-tree 7 (make-tree 3 1 5) (make-tree 9 '() 11)))
(define b (make-tree 3
                     0
                     (make-tree 6
                                5 
                                (make-tree 9 '() 11)
                     )
          )
)
(newline)
(display a)(newline)
(display b)(newline)
(display (tree->list a))(newline)
(display (tree->list b))(newline)
(display (inter-tree-set a b))(newline)
(display (union-tree-set a b))(newline)